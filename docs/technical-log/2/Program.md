# 从机器码到高级编程语言<Badge type="warning" text="主线2/3" />
::: tip :tada:
Coming Soon~!
:::

## 机器码：真正的底层语言

最早的计算机是使用 **机器码** 进行编程的。机器码由二进制指令组成，直接控制硬件操作。然而，机器码对人类来说极其晦涩难懂，编写和调试程序不仅费时费力，而且难以维护。为了解决这一问题，**高级语言** 应运而生。

高级语言使用人类易读的符号来标记数据和算法，再通过 **编译器** 将这些符号代码翻译成机器码。

::: tip
在计算机发展的早期，计算机主要服务于 **科学计算** 和 **商业领域**，因此最早普及的高级编程语言是 **FORTRAN** 和 **COBOL**。FORTRAN 专注于科学计算和数值分析，而 COBOL 则面向商业数据处理，两者极大地提高了编程效率和代码的可读性。
:::

高级语言的思想促生了多种多样的编程语言。而所有的编程语言，无论经过多么复杂的流程，编译也好实时解释也罢，最终都要变为机器码才能在CPU中运行。他们都遵循着:`code->编译器->机器码`结构。而这其中，与机器码最接近的当属**汇编语言**了。

## 汇编：与ISA纠缠发展的语言

随着计算机应用场景的扩展，人们对计算机性能的需求逐渐提高。与此同时，**微处理器** 的出现（如 1971 年 Intel 4004）和 **冯·诺依曼架构** 的普及，使得计算机需要更直接地操作硬件资源（如寄存器、内存地址）。在这种背景下，**汇编语言** 脱颖而出。

::: tip
值得注意的是，汇编语言并不是与 CPU 一起出现的，它的理论和应用可以追溯到 20 世纪 40 年代末到 50 年代初，远早于微处理器的诞生。汇编语言最初是为了简化机器码编程而设计的，但由于其直接操作硬件的能力，它在系统编程和性能优化中发挥了重要作用。直到人们对计算机性能的需求增加，汇编语言才真正得以普及。
:::

汇编语言是一种 低级语言，它使用助记符（如 MOV、ADD）代替二进制指令，更接近人类语言。优势在于它能够**直接操作硬件**，例如访问寄存器、内存地址等。这使得它在**系统编程**和**性能优化**中具有不可替代的作用。

::: details 这里放了汇编语言的样子
```asm
section .data
    num db 10      ; 定义一个字节变量 num，值为 10

section .text
    global _start

_start:
    mov eax, [num] ; 将 num 的值加载到寄存器 eax
    add eax, 5     ; 将 eax 的值加 5
    mov [num], eax ; 将结果存储回 num

    ; 退出程序
    mov eax, 1      ; 系统调用号 1（退出）
    xor ebx, ebx    ; 返回码 0
    int 0x80        ; 调用内核
```
**解释:**

`MOV`：数据移动指令，将数据从一个位置复制到另一个位置。

`ADD`：加法指令，将两个数相加。

`INT 0x80`：触发系统调用，用于与操作系统交互。
:::

### ISA（Instruction Set Architecture，指令集架构）

指令集这个名字可能比较陌生，但我提到 **x86 架构**，你一定略有耳闻。指令集架构（ISA）是 CPU 设计的一部分，定义了 CPU 能够理解和执行的所有指令的集合。它是硬件与软件之间的桥梁，决定了编程语言如何与 CPU 交互。

> 指令集和汇编语言是 **相互依存、共同发展** 的。指令集是汇编语言的基础，汇编语言中的每一条指令都直接对应指令集中的一条机器码，例如 x86 指令集中的 `MOV` 指令对应汇编语言中的 `MOV` 助记符。汇编语言通过助记符（如 `MOV`、`ADD`）将机器码抽象为人类可读的形式，使得程序员能够更直观地编写和理解代码。同时，指令集的设计影响了汇编语言的功能和表达能力，而汇编语言的使用反馈也推动了指令集的改进和扩展，二者共同推动了计算机技术的发展。

#### 指令集的分类

指令集可以根据其复杂性和设计哲学分为两大类：

1. **CISC（Complex Instruction Set Computer，复杂指令集计算机）**：
   - **特点**：指令集庞大，指令功能复杂，一条指令可以完成多个操作。
   - **典型代表**：x86 架构（用于 PC 和服务器）。
   - **优势**：适合通用计算，编程效率高。
   - **劣势**：硬件设计复杂，功耗较高。

2. **RISC（Reduced Instruction Set Computer，精简指令集计算机）**：
   - **特点**：指令集精简，指令功能简单，一条指令通常只完成一个操作。
   - **典型代表**：ARM 架构（用于手机、平板和嵌入式设备）。
   - **优势**：硬件设计简单，功耗低，适合移动设备和嵌入式系统。
   - **劣势**：编程效率较低，需要更多指令完成复杂操作。

#### 日常生活中常见的指令集

指令集不仅是计算机的核心，还广泛应用于我们日常使用的各种设备中。以下是几种常见的指令集及其应用场景：

1. **x86 架构**：
   - **应用**：个人电脑（PC）、服务器。
   - **特点**：高性能，适合通用计算。
   - **代表厂商**：Intel、AMD。

::: tip
**x86** 是 Intel 推出的 32 位架构，广泛应用于个人电脑和服务器。**AMD64** 是 AMD 推出的 64 位扩展架构，完全兼容 x86，并引入了 64 位寄存器和地址空间。AMD64 在保留 x86 兼容性的同时，提供了更强的 64 位计算能力，成为现代 64 位计算的主流架构。Intel 后来也采用了类似的设计，称为 **Intel 64**。
:::

2. **ARM 架构**：
   - **应用**：智能手机、平板电脑、嵌入式设备（如智能家居、物联网设备）。
   - **特点**：低功耗，适合移动设备和嵌入式系统。
   - **代表厂商**：Qualcomm、Apple、Samsung。

3. **MIPS 架构**：
   - **应用**：路由器、网络设备、嵌入式系统。
   - **特点**：设计简洁，适合特定领域的嵌入式应用。
   - **代表厂商**：Broadcom、Cisco。

4. **RISC-V 架构**：
   - **应用**：新兴的嵌入式设备、学术研究。
   - **特点**：开源、模块化设计，适合定制化开发。
   - **代表厂商**：SiFive、Western Digital。

---

指令集架构（ISA）是计算机硬件的核心，它定义了 CPU 如何执行指令。汇编语言是指令集的抽象，使得程序员能够更直观地编写和理解代码。从 **x86** 到 **ARM**，再到 **RISC-V**，不同的指令集架构支撑着我们日常使用的各种设备，推动了计算机技术的不断发展。

## C语言：贯通抽象与底层的系统之魂

如果把编程语言比作一个大家族，C语言就是那位德高望重的“祖父”——你可能没和他直接打过交道，但你现在用的手机、电脑、甚至银行卡系统，背后全是他奠定的规则。这个故事要从50年前说起：

### 1970年代：从实验室诞生的「革命工具」
* 贝尔实验室的丹尼斯·里奇（Dennis Ritchie）为了重写Unix系统（没错，就是如今MacOS、iOS和安卓系统的远祖），创造了C语言。

* 为什么是革命？ 以前的编程语言要么难到只有专家能用（汇编），要么效率低下（B语言）。C语言第一次做到了**既让人类能轻松写代码，又能精准控制计算机硬件**，堪称“高级语言中的操控大师”。

### 1980年代：成为数字世界的「隐形规则书」
C语言随着Unix系统横扫全球，甚至微软Windows内核也大量使用C。更关键的是，它成了**编程语言的设计模板**：

* **徒弟辈**：C++在C基础上加了“面向对象”功能

* **孙辈**：Java、C#、JavaScript的语法都神似C语言

* **跨界影响**：Python的解释器、Redis数据库、Node.js底层……无数明星工具靠C语言支撑核心性能

### 今天：活在每台设备里的「活化石」

* **你的手机里藏着C语言**：安卓系统用C/C++开发，iOS的Objective-C本质是C的超集

* **它从不过时**：近50年稳居编程语言排行榜前3名（2023年TIOBE榜单第2）

* **为什么程序员又爱又恨？**
   * 爱：直接操作内存和硬件（比如用指针精准控制摄像头传感器数据），C语言的高速运行效率是其他语言无法比拟的。
   * 恨：自由伴随风险，正是因为可以直接操作内存，也就多出了很多与程序业务无关的工作（手动分配和释放内存），不易读又容易忘记。

C语言像空气，它早已渗透到数字世界的每个角落，尽管你很少察觉它的存在。
C语言是人类从复杂的、业务无关的机器控制中向上抽离的一次非常成功的经历，后续的几乎所有高级语言，其实都是重复这个步骤。即向上抽离，封装复杂的、业务无关的操作，让程序员能更加专注业务逻辑处理，甚至连各编程语言生态中的工具和框架也是这个目的。

::: tip
1991年，22岁的林纳斯·托瓦兹用**C语言**在386电脑上写下第一行Linux内核代码——这个选择绝非偶然。当时主流的操作系统要么臃肿（如Unix商用版），要么功能残缺（如教学用Minix），而C语言的**直接内存操作能力**（通过`kmalloc()`/`kfree()`函数）和**硬件抽象能力**（用`struct task_struct`结构体定义进程），让林纳斯得以像搭积木般构建出**跨平台内核架构**。  

**一个冷知识**：Linux 1.0版本内核（1994年）中C语言代码占比高达99%，至今仍有超58%的代码由C语言写成。正是C的**指针自由度**让Linux能精准操控硬件中断，而GCC编译器（同样用C编写）则完成了从代码到世界级操作系统的终极魔法。
:::
::: details C语言长这个样子
``` C
#include <stdio.h>

int main() {
    // 定义两个整数变量并赋值
    int num1 = 5;
    int num2 = 7;

    // 计算两数之和
    int sum = num1 + num2;

    // 打印输出结果
    printf("The sum of %d and %d is %d.\n", num1, num2, sum);

    return 0; // 返回0表示程序正常结束
}
```
:::

**程序是业务的数字体现**

**业务是程序的逻辑依托**

