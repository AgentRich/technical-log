# 从机器码到高级编程语言<Badge type="warning" text="主线2/3" />

## 机器码：真正的底层语言

最早的计算机是使用 **机器码** 进行编程的。机器码由二进制指令组成，直接控制硬件操作。然而，机器码对人类来说极其晦涩难懂，编写和调试程序不仅费时费力，而且难以维护。为了解决这一问题，**高级语言** 应运而生。

高级语言使用人类易读的符号来标记数据和算法，再通过 **编译器** 将这些符号代码翻译成机器码。

::: tip
在计算机发展的早期，计算机主要服务于 **科学计算** 和 **商业领域**，因此最早普及的高级编程语言是 **FORTRAN** 和 **COBOL**。FORTRAN 专注于科学计算和数值分析，而 COBOL 则面向商业数据处理，两者极大地提高了编程效率和代码的可读性。
:::

高级语言的思想促生了多种多样的编程语言。而所有的编程语言，无论经过多么复杂的流程，编译也好实时解释也罢，最终都要变为机器码才能在CPU中运行。他们都遵循着:`code->编译器->机器码`结构。而这其中，与机器码最接近的当属**汇编语言**了。

## 汇编：与ISA纠缠发展的语言

随着计算机应用场景的扩展，人们对计算机性能的需求逐渐提高。与此同时，**微处理器** 的出现（如 1971 年 Intel 4004）和 **冯·诺依曼架构** 的普及，使得计算机需要更直接地操作硬件资源（如寄存器、内存地址）。在这种背景下，**汇编语言** 脱颖而出。

::: tip
值得注意的是，汇编语言并不是与 CPU 一起出现的，它的理论和应用可以追溯到 20 世纪 40 年代末到 50 年代初，远早于微处理器的诞生。汇编语言最初是为了简化机器码编程而设计的，但由于其直接操作硬件的能力，它在系统编程和性能优化中发挥了重要作用。直到人们对计算机性能的需求增加，汇编语言才真正得以普及。
:::

汇编语言是一种 低级语言 ，它使用助记符（如 MOV、ADD）代替二进制指令，更接近人类语言。优势在于它能够**直接操作硬件**，例如访问寄存器、内存地址等。这使得它在**系统编程**和**性能优化**中具有不可替代的作用。


::: details 这里放了汇编语言的样子
```asm
section .data
    num db 10      ; 定义一个字节变量 num，值为 10

section .text
    global _start

_start:
    mov eax, [num] ; 将 num 的值加载到寄存器 eax
    add eax, 5     ; 将 eax 的值加 5
    mov [num], eax ; 将结果存储回 num

    ; 退出程序
    mov eax, 1      ; 系统调用号 1（退出）
    xor ebx, ebx    ; 返回码 0
    int 0x80        ; 调用内核
```
**解释:**

`MOV`：数据移动指令，将数据从一个位置复制到另一个位置。

`ADD`：加法指令，将两个数相加。

`INT 0x80`：触发系统调用，用于与操作系统交互。
:::

### ISA（Instruction Set Architecture，指令集架构）

指令集这个名字可能比较陌生，但我提到 **x86 架构**，你一定略有耳闻。指令集架构（ISA）是 CPU 设计的一部分，定义了 CPU 能够理解和执行的所有指令的集合。它是硬件与软件之间的桥梁，决定了编程语言如何与 CPU 交互。

> 指令集和汇编语言是 **相互依存、共同发展** 的。指令集是汇编语言的基础，汇编语言中的每一条指令都直接对应指令集中的一条机器码，例如 x86 指令集中的 `MOV` 指令对应汇编语言中的 `MOV` 助记符。汇编语言通过助记符（如 `MOV`、`ADD`）将机器码抽象为人类可读的形式，使得程序员能够更直观地编写和理解代码。同时，指令集的设计影响了汇编语言的功能和表达能力，而汇编语言的使用反馈也推动了指令集的改进和扩展，二者共同推动了计算机技术的发展。

#### 指令集的分类

指令集可以根据其复杂性和设计哲学分为两大类：

1. **CISC（Complex Instruction Set Computer，复杂指令集计算机）**：
   - **特点**：指令集庞大，指令功能复杂，一条指令可以完成多个操作。
   - **典型代表**：x86 架构（用于 PC 和服务器）。
   - **优势**：适合通用计算，编程效率高。
   - **劣势**：硬件设计复杂，功耗较高。

2. **RISC（Reduced Instruction Set Computer，精简指令集计算机）**：
   - **特点**：指令集精简，指令功能简单，一条指令通常只完成一个操作。
   - **典型代表**：ARM 架构（用于手机、平板和嵌入式设备）。
   - **优势**：硬件设计简单，功耗低，适合移动设备和嵌入式系统。
   - **劣势**：编程效率较低，需要更多指令完成复杂操作。

#### 日常生活中常见的指令集

指令集不仅是计算机的核心，还广泛应用于我们日常使用的各种设备中。以下是几种常见的指令集及其应用场景：

1. **x86 架构**：
   - **应用**：个人电脑（PC）、服务器。
   - **特点**：高性能，适合通用计算。
   - **代表厂商**：Intel、AMD。

::: tip
**x86** 是 Intel 推出的 32 位架构，广泛应用于个人电脑和服务器。**AMD64** 是 AMD 推出的 64 位扩展架构，完全兼容 x86，并引入了 64 位寄存器和地址空间。AMD64 在保留 x86 兼容性的同时，提供了更强的 64 位计算能力，成为现代 64 位计算的主流架构。Intel 后来也采用了类似的设计，称为 **Intel 64**。
:::

2. **ARM 架构**：
   - **应用**：智能手机、平板电脑、嵌入式设备（如智能家居、物联网设备）。
   - **特点**：低功耗，适合移动设备和嵌入式系统。
   - **代表厂商**：Qualcomm、Apple、Samsung。

3. **MIPS 架构**：
   - **应用**：路由器、网络设备、嵌入式系统。
   - **特点**：设计简洁，适合特定领域的嵌入式应用。
   - **代表厂商**：Broadcom、Cisco。

4. **RISC-V 架构**：
   - **应用**：新兴的嵌入式设备、学术研究。
   - **特点**：开源、模块化设计，适合定制化开发。
   - **代表厂商**：SiFive、Western Digital。

---

指令集架构（ISA）是计算机硬件的核心，它定义了 CPU 如何执行指令。汇编语言是指令集的抽象，使得程序员能够更直观地编写和理解代码。从 **x86** 到 **ARM**，再到 **RISC-V**，不同的指令集架构支撑着我们日常使用的各种设备，推动了计算机技术的不断发展。

## C语言：贯通抽象与底层的系统之魂

如果把编程语言比作一个大家族，C语言就是那位德高望重的“祖父”——你可能没和他直接打过交道，但你现在用的手机、电脑、甚至银行卡系统，背后全是他奠定的规则。这个故事要从50年前说起：

### 1970年代：从实验室诞生的「革命工具」
* 贝尔实验室的丹尼斯·里奇（Dennis Ritchie）为了重写Unix系统（没错，就是如今MacOS、iOS和安卓系统的远祖），创造了C语言。

* 为什么是革命？ 以前的编程语言要么难到只有专家能用（汇编），要么效率低下（B语言）。C语言第一次做到了**既让人类能轻松写代码，又能精准控制计算机硬件**，堪称“高级语言中的操控大师”。

### 1980年代：成为数字世界的「隐形规则书」
C语言随着Unix系统横扫全球，甚至微软Windows内核也大量使用C。更关键的是，它成了**编程语言的设计模板**：

* **徒弟辈**：C++在C基础上加了“面向对象”功能

* **孙辈**：Java、C#、JavaScript的语法都神似C语言

* **跨界影响**：Python的解释器、Redis数据库、Node.js底层……无数明星工具靠C语言支撑核心性能

### 今天：活在每台设备里的「活化石」

* **你的手机里藏着C语言**：安卓系统用C/C++开发，iOS的Objective-C本质是C的超集

* **它从不过时**：近50年稳居编程语言排行榜前3名（2023年TIOBE榜单第2）

* **为什么程序员又爱又恨？**
   * 爱：直接操作内存和硬件（比如用指针精准控制摄像头传感器数据），C语言的高速运行效率是其他语言无法比拟的。
   * 恨：自由伴随风险，正是因为可以直接操作内存，也就多出了很多与程序业务无关的工作（手动分配和释放内存），不易读又容易忘记。

C语言像空气，它早已渗透到数字世界的每个角落，尽管你很少察觉它的存在。
C语言是人类从复杂的、业务无关的机器控制中向上抽离的一次非常成功的经历，后续的几乎所有高级语言，其实都是重复这个步骤。即向上抽离，封装复杂的、业务无关的操作，让程序员能更加专注业务逻辑处理，甚至连各编程语言生态中的工具和框架也是这个目的。

::: tip
1991年，22岁的林纳斯·托瓦兹用**C语言**在386电脑上写下第一行Linux内核代码——这个选择绝非偶然。当时主流的操作系统要么臃肿（如Unix商用版），要么功能残缺（如教学用Minix），而C语言的**直接内存操作能力**（通过`kmalloc()`/`kfree()`函数）和**硬件抽象能力**（用`struct task_struct`结构体定义进程），让林纳斯得以像搭积木般构建出**跨平台内核架构**。  

**一个冷知识**：Linux 1.0版本内核（1994年）中C语言代码占比高达99%，至今仍有超58%的代码由C语言写成。正是C的**指针自由度**让Linux能精准操控硬件中断，而GCC编译器（同样用C编写）则完成了从代码到世界级操作系统的终极魔法。
:::
::: details C语言长这个样子
``` C
#include <stdio.h>

int main() {
    // 定义两个整数变量并赋值
    int num1 = 5;
    int num2 = 7;

    // 计算两数之和
    int sum = num1 + num2;

    // 打印输出结果
    printf("The sum of %d and %d is %d.\n", num1, num2, sum);

    return 0; // 返回0表示程序正常结束
}
```
:::

## 高级语言：不断向上抽象的过程

从C语言缔造了操作系统之后，计算机也随之有了更多应用场景，踏入了百行千业之中。但随之而来的并不是各行各业对C语言的普遍使用，而是大部分时间，编程人员都在调整底层硬件与业务的匹配程度。随着历史的发展，人们发现，C语言在业务匹配上的高成本和不同系统间的兼容性会耗费巨大的精力，却不能提升程序的生产速度。于是人们开始设计新的、更高级的、更易读的、更能专注业务逻辑的、更兼容的编程语言。
由于篇幅限制，这里并不能介绍井喷式发展时期出现的所有编程语言。下面我只介绍几种为大众所熟知，并且对编程范式有重要影响的编程语言。
借此来展示编程语言飞速发展时期的向上抽象的过程。

### C++：在刀尖上跳舞的平衡艺术
**向上抽象的进展**：引入面向对象，但保留硬件操控能力。

* **1983年诞生**：通过类和模板实现代码复用，但需手动管理内存（如new/delete）。
* **典型场景**：游戏引擎（Unreal Engine）、高频交易系统。
* **抽象本质**：剥离了C语言中的内存管理操作，将其封装为一行代码即可使用内存的逻辑。

::: details C++标准库长期缺乏原生的HTTP支持，需依赖第三方库实现网络功能，所以这里只举获取文件资源的例子。
``` C++
#include <fstream>
#include <memory>

int main() {
    // 智能指针自动管理文件资源
    auto file = std::make_shared<std::ifstream>("data.txt");
    std::string content;
    // 高级流操作替代系统调用
    std::getline(*file, content);
    return 0;
}
```
:::

### Java：虚拟机时代的标准化革命
**向上抽象的进展**：通过JVM完全屏蔽硬件差异。

* **1995年推出**： "一次编写，到处运行"的JVM，但字节码需通过JIT编译执行，就是说想要运行首先需要有JVM才行。
* **典型场景**：企业级应用后台服务端、Android App开发。
* **抽象本质**：其提出的JVM，采用了完全重新设计的内存管理机制，像是重新设计了一个系统一样，开发者无需关心CPU架构和内存管理，但牺牲实时性。

::: tip
其实Java的最初设计是向机器控制（嵌入式）方向发展的，但是随着互联网浪潮的来临，企业级服务端需求爆发，Sun公司敏锐的嗅到了商机，并快速调整了Java语言的定位。这才有了Java在服务端的统治地位。当然随着移动互联网的到来，Java的兼容性展现出了莫大的价值，从而顺手统治了Android市场。（不过截至到写作时间，Android的开发已经更换为Kotlin有一段时间了，但Kt和Java又有着极强的兼容性，所以这个统治者到底是谁，不必深究）
:::

::: details Java的HTTP请求
``` Java
import java.net.*;

public class Main {
    public static void main(String[] args) throws Exception {
        // URL类封装网络协议细节
        URL url = new URL("https://api.example.com");
        // 自动处理连接/异常
        String response = new BufferedReader(
            new InputStreamReader(url.openStream())
        ).readLine();
    }
}
```
:::

### Python：用可读性换取开发效率
**向上抽象的进展**：完全隐藏内存管理，聚焦业务逻辑。

* **1991年诞生**：强制缩进语法倒逼代码可读性，让看代码就像英语文本阅读一样简单，但解释执行速度仅为C的1/100。
* **典型场景**：机器学习领域、数据分析领域。
* **抽象本质**：剥离了变量类型，让开发者彻底从内存管理中脱离。同时得益于官方的生态支持，让其得以非常方便的调用各种软件库，这让Python变成了各科学领域的胶水语言，所以其在科学研究、数据运算和分析领域具有统治级地位。

::: details Python的HTTP请求
``` Python
import requests

def get_data():
    # 一行代码完成HTTP请求
    return requests.get("https://api.example.com").json()
```
:::

### JavaScript：意外统治前端的语言
**向上抽象的进展**：用动态类型解放开发束缚。

* **1995年仅用10天设计**：却成为Web唯一原生语言。
* **典型场景**：浏览器标准脚本语言、Node.js环境语言（服务端和桌面端应用）。
* **抽象本质**：打破不同功能必须设计在不同软件中的设定，同时开启了异步编程的范式革命。

::: tip
JavaScript最初由网景公司（Netscape）的布兰登·艾奇设计，原名**LiveScript** 。1995年，在Sun公司授权下更名为**JavaScript**，目的是借助Java语言的热度推广（尽管两者无技术关联）。这一命名策略源于网景与Sun的商业合作：Sun希望通过Java生态扩展影响力，而网景则试图通过“Java的脚本版”定位快速占领浏览器市场。为避免商标争议，JavaScript后续通过ECMA标准化为**ECMAScript** ，但名称的历史渊源仍常引发误解。
所以行业中所说的ES5、ES6等标准，指的就是**ECMAScript**的标准。
:::

::: details JS HTTP请求
``` JavaScript
// 使用async/await语法糖
async function fetchData() {
    // 浏览器自动处理HTTP协议
    const response = await fetch('https://api.example.com');
    return await response.json();
}
```
:::

我们来看一组**Qwen**给出的对比表格：
> | 语言   | 典型性能（生活化类比）                        | 内存控制             | 硬件可见性 | 适用架构       |
> |--------|-----------------------------------------------|----------------------|------------|----------------|
> | C      | 1秒处理1000万次运算（F1赛车直道狂飙）         | 手动（机械师级）     | 寄存器级   | 嵌入式系统     |
> | C++    | 1秒处理83万次运算（带导航的F1赛车）           | 半自动（带辅助驾驶） | 内存地址   | 游戏服务器     |
> | Java   | 1秒处理2000次运算（高铁准时运行）             | 自动（全自动驾驶）   | JVM黑盒    | 企业级C/S系统  |
> | Python | 1秒处理100次运算（出租车随机应变）            | 无（乘客无需操心）   | 无          | 快速开发B/S系统|
> | JavaScript | 1秒处理50次运算（外卖小哥灵活送餐）       | 无（平台自动分配）   | 浏览器沙箱隔离   | Web前端/Node.js服务端 |

## 总结
恭喜你，如果你读到了这里，代表你已经大概了解了编程语言的演进历史和他们分别专注的领域。当然没有提到的编程语言也很多，专注于新兴领域的语言一个人也不可能做到完全了解。所以在这里我更希望谈一些我个人对编程语言的理解：

首先，前文所述的低级语言指的并不是编程语言的高低，而是此种语言与底层硬件的接近程度。越低级性能越好，但也越不易读；反之，越高级的语言越易读，但由于易读的本质是去除代码中操作硬件的部分，让编程人员更专注于业务逻辑。所以高级语言易读的同时也牺牲了性能。
编程语言从低级向高级的演变过程，本质上是人们从业务无关代码向业务专注代码的不断进化。直到写作时间（2025年3月8日），AI已经步入人们的生活，自然语言已经在逐渐进化为最新的编程语言，这预示着，在传统互联网服务和软件行业中，编程语言已经抽象到了最顶层（即自然语言）。接下来的脑电波可能已经不能再将其称之为语言了。

然后，我们需要注意到，其实每次编程语言的演进，剥离的基本都是内存管理和编程范式。说白了，就是数据和算法上的演进。后面会有一篇`编程语言的本质：与CPU对话和内存管理`带你了解所有编程语言的本质，让你半小时学会读懂所有代码。

最后，无论是任何编程语言都是要编写程序的，否则就成了无字空书。而所有程序均需要遵循业务逻辑，也就是解决实际问题的逻辑。程序的设计与业务逻辑是相生相长、密不可分的关系。至此，我希望用一句之前培训时灵感涌现出来的话来总结我5年程序猿职业生涯中对此关系的理解，作为章节的结语：

**程序是业务的数字体现**

**业务是程序的逻辑依托**

